<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pizza Delivery Pixel Game</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background-color: #222;
            color: white;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: manipulation;
        }
        canvas {
            border: 2px solid #fff;
            background-color: #333;
            max-width: 90vw;
            max-height: 60vh;
        }
        .info {
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        .controls {
            margin-bottom: 10px;
            text-align: center;
            font-size: 12px;
        }
        .mobile-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            width: 200px;
            height: 200px;
        }
        .mobile-btn {
            background-color: #555;
            border: 2px solid #777;
            color: white;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mobile-btn:active {
            background-color: #888;
            border-color: #aaa;
        }
        .mobile-btn[data-direction="up"] {
            grid-column: 2;
            grid-row: 1;
        }
        .mobile-btn[data-direction="left"] {
            grid-column: 1;
            grid-row: 2;
        }
        .mobile-btn[data-direction="right"] {
            grid-column: 3;
            grid-row: 2;
        }
        .mobile-btn[data-direction="down"] {
            grid-column: 2;
            grid-row: 3;
        }
        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
        }
        @media (max-width: 767px) {
            body {
                padding: 5px;
            }
            canvas {
                max-width: 95vw;
                max-height: 50vh;
            }
            .controls p:first-child {
                display: none;
            }
        }
        .recording-controls {
            margin: 15px 0;
            text-align: center;
        }
        .record-btn {
            background-color: #333;
            border: 2px solid #555;
            color: white;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
        }
        .record-btn:hover {
            background-color: #555;
        }
        .record-btn.recording {
            background-color: #ff0000;
            border-color: #ff3333;
            animation: pulse 1.5s infinite;
        }
        .record-btn.disabled {
            background-color: #666;
            border-color: #888;
            cursor: not-allowed;
            opacity: 0.5;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .recording-status {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
        .recording-status.active {
            color: #ff6666;
        }
    </style>
</head>
<body>
    <div class="controls">
        <p>Use WASD or Arrow Keys to move the blue pixel (player)</p>
        <p>Pick up pizzas (red pixels) from the counter and deliver to guests (green pixels)</p>
        <button onclick="loadConfig()">Load Custom Config</button>
        <input type="file" id="configFile" accept=".json" style="display:none" onchange="handleConfigFile(event)">
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="info">
        <p>Score: <span id="score">0</span> | Pizzas Carried: <span id="pizzasCarried">0</span></p>
        <p>Active Requests: <span id="activeRequests">0</span></p>
    </div>

    <div class="recording-controls">
        <button id="recordBtn" class="record-btn" onclick="toggleRecording()">üî¥ Start Recording</button>
        <button id="exportBtn" class="record-btn disabled" onclick="exportRecording()" disabled>üì• Export Session</button>
        <div id="recordingStatus" class="recording-status">Ready to record gameplay and audio</div>
    </div>

    <div class="mobile-controls">
        <div class="mobile-btn" data-direction="up">‚Üë</div>
        <div class="mobile-btn" data-direction="left">‚Üê</div>
        <div class="mobile-btn" data-direction="right">‚Üí</div>
        <div class="mobile-btn" data-direction="down">‚Üì</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const pizzasCarriedElement = document.getElementById('pizzasCarried');
        const activeRequestsElement = document.getElementById('activeRequests');

        // Default game configuration - 5x5 grid system
        let gameConfig = {
            maxGuests: 2,
            maxPizzasAtCounter: 1,
            gridSize: 5, // 5x5 grid
            cellSize: 80, // Each cell is 80px
            playerMaxPizzas: 3,
            scorePerDelivery: 10,
            pizzaRespawnDelay: 2000,
            guestRespawnDelay: 3000,
            canvas: {
                width: 400, // 5 * 80
                height: 400 // 5 * 80
            },
            counter: {
                gridX: 4, // rightmost column
                gridY: 1, // second row
                gridWidth: 1,
                gridHeight: 2
            },
            player: {
                startGridX: 0,
                startGridY: 2
            }
        };

        // Game state with grid positions
        const game = {
            player: {
                gridX: gameConfig.player.startGridX,
                gridY: gameConfig.player.startGridY,
                pizzasCarried: 0,
                maxPizzas: gameConfig.playerMaxPizzas
            },
            pizzas: [],
            guests: [],
            counter: gameConfig.counter,
            score: 0,
            keys: {},
            touchControls: {}
        };

        // Recording system
        const recording = {
            isRecording: false,
            startTime: null,
            keystrokes: [],
            audioData: null,
            transcription: [],
            mediaRecorder: null,
            recognition: null,
            audioChunks: [],
            gameFrames: [],
            gameId: null,
            actionCounter: 0
        };

        // Generate unique IDs
        function generateGameId() {
            const timestamp = Date.now().toString(36);
            const random = Math.random().toString(36).substr(2, 8);
            return `ls20-${timestamp}${random}`;
        }

        function generateGuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Helper functions for grid conversion
        function gridToPixel(gridPos) {
            return gridPos * gameConfig.cellSize;
        }

        function pixelToGrid(pixelPos) {
            return Math.floor(pixelPos / gameConfig.cellSize);
        }

        function isValidGridPosition(x, y) {
            return x >= 0 && x < gameConfig.gridSize && y >= 0 && y < gameConfig.gridSize;
        }

        // Initialize game objects
        function initGame() {
            // Create initial pizzas at counter
            spawnPizza();

            // Create initial guests
            spawnGuest();
            spawnGuest();
        }

        function spawnPizza() {
            if (game.pizzas.length < gameConfig.maxPizzasAtCounter) {
                // Spawn pizza in counter area
                const counterGridX = gameConfig.counter.gridX;
                const counterGridY = gameConfig.counter.gridY + Math.floor(Math.random() * gameConfig.counter.gridHeight);

                game.pizzas.push({
                    gridX: counterGridX,
                    gridY: counterGridY,
                    available: true
                });
            }
        }

        function spawnGuest() {
            if (game.guests.length < gameConfig.maxGuests) {
                let gridX, gridY;
                do {
                    gridX = Math.floor(Math.random() * gameConfig.gridSize);
                    gridY = Math.floor(Math.random() * gameConfig.gridSize);
                } while (
                    // Don't spawn guests in counter area or on player
                    (gridX >= gameConfig.counter.gridX - 1 && gridX <= gameConfig.counter.gridX + gameConfig.counter.gridWidth &&
                     gridY >= gameConfig.counter.gridY - 1 && gridY <= gameConfig.counter.gridY + gameConfig.counter.gridHeight) ||
                    (gridX === game.player.gridX && gridY === game.player.gridY)
                );

                game.guests.push({
                    gridX: gridX,
                    gridY: gridY,
                    needsPizza: true,
                    requestTime: Date.now()
                });
            }
        }

        // Input handling - keyboard
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;

            // Record keystroke if recording
            if (recording.isRecording) {
                recordKeystroke(e.key.toLowerCase(), 'keydown', Date.now() - recording.startTime);
            }
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;

            // Record keystroke if recording
            if (recording.isRecording) {
                recordKeystroke(e.key.toLowerCase(), 'keyup', Date.now() - recording.startTime);
            }
        });

        // Input handling - mobile touch controls
        document.addEventListener('DOMContentLoaded', () => {
            const mobileButtons = document.querySelectorAll('.mobile-btn');
            mobileButtons.forEach(btn => {
                const direction = btn.dataset.direction;

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    game.touchControls[direction] = true;

                    // Record touch if recording
                    if (recording.isRecording) {
                        recordKeystroke(direction, 'touchstart', Date.now() - recording.startTime);
                    }
                }, {passive: false});

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    game.touchControls[direction] = false;

                    // Record touch if recording
                    if (recording.isRecording) {
                        recordKeystroke(direction, 'touchend', Date.now() - recording.startTime);
                    }
                }, {passive: false});

                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    game.touchControls[direction] = true;

                    // Record mouse if recording
                    if (recording.isRecording) {
                        recordKeystroke(direction, 'mousedown', Date.now() - recording.startTime);
                    }
                });

                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    game.touchControls[direction] = false;

                    // Record mouse if recording
                    if (recording.isRecording) {
                        recordKeystroke(direction, 'mouseup', Date.now() - recording.startTime);
                    }
                });
            });
        });

        // Movement cooldown to prevent too rapid movement
        let lastMoveTime = 0;
        const moveCooldown = 200; // ms

        // Update game logic
        function update() {
            const currentTime = Date.now();

            // Grid-based player movement with cooldown
            if (currentTime - lastMoveTime > moveCooldown) {
                let moved = false;

                if (game.keys['w'] || game.keys['arrowup'] || game.touchControls['up']) {
                    if (isValidGridPosition(game.player.gridX, game.player.gridY - 1)) {
                        game.player.gridY--;
                        moved = true;
                    }
                }
                if (game.keys['s'] || game.keys['arrowdown'] || game.touchControls['down']) {
                    if (isValidGridPosition(game.player.gridX, game.player.gridY + 1)) {
                        game.player.gridY++;
                        moved = true;
                    }
                }
                if (game.keys['a'] || game.keys['arrowleft'] || game.touchControls['left']) {
                    if (isValidGridPosition(game.player.gridX - 1, game.player.gridY)) {
                        game.player.gridX--;
                        moved = true;
                    }
                }
                if (game.keys['d'] || game.keys['arrowright'] || game.touchControls['right']) {
                    if (isValidGridPosition(game.player.gridX + 1, game.player.gridY)) {
                        game.player.gridX++;
                        moved = true;
                    }
                }

                if (moved) {
                    lastMoveTime = currentTime;
                }
            }

            // Check pizza pickup (grid-based collision)
            game.pizzas.forEach((pizza, index) => {
                if (pizza.available &&
                    game.player.pizzasCarried < game.player.maxPizzas &&
                    game.player.gridX === pizza.gridX &&
                    game.player.gridY === pizza.gridY) {
                    game.player.pizzasCarried++;
                    game.pizzas.splice(index, 1);

                    // Spawn new pizza after a delay
                    setTimeout(spawnPizza, gameConfig.pizzaRespawnDelay);
                }
            });

            // Check pizza delivery to guests (grid-based collision)
            game.guests.forEach((guest, index) => {
                if (guest.needsPizza &&
                    game.player.pizzasCarried > 0 &&
                    game.player.gridX === guest.gridX &&
                    game.player.gridY === guest.gridY) {
                    game.player.pizzasCarried--;
                    game.score += gameConfig.scorePerDelivery;
                    game.guests.splice(index, 1);

                    // Spawn new guest after delivery
                    setTimeout(spawnGuest, gameConfig.guestRespawnDelay);
                }
            });

            // Update UI
            scoreElement.textContent = game.score;
            pizzasCarriedElement.textContent = game.player.pizzasCarried;
            activeRequestsElement.textContent = game.guests.filter(g => g.needsPizza).length;
        }

        // Grid collision is now handled by comparing grid positions directly

        // Render game with grid system
        function render() {
            // Clear canvas
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines (optional visual aid)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = 0; i <= gameConfig.gridSize; i++) {
                const pos = i * gameConfig.cellSize;
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, canvas.height);
                ctx.stroke();
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(canvas.width, pos);
                ctx.stroke();
            }

            // Draw counter area
            ctx.fillStyle = '#666';
            const counterX = gridToPixel(gameConfig.counter.gridX);
            const counterY = gridToPixel(gameConfig.counter.gridY);
            const counterWidth = gameConfig.counter.gridWidth * gameConfig.cellSize;
            const counterHeight = gameConfig.counter.gridHeight * gameConfig.cellSize;
            ctx.fillRect(counterX, counterY, counterWidth, counterHeight);

            ctx.fillStyle = '#888';
            ctx.fillRect(counterX + 4, counterY + 4, counterWidth - 8, counterHeight - 8);

            // Draw pizzas (red squares)
            ctx.fillStyle = '#ff0000';
            game.pizzas.forEach(pizza => {
                const x = gridToPixel(pizza.gridX) + 10;
                const y = gridToPixel(pizza.gridY) + 10;
                const size = gameConfig.cellSize - 20;
                ctx.fillRect(x, y, size, size);
            });

            // Draw guests (green squares)
            ctx.fillStyle = '#00ff00';
            game.guests.forEach(guest => {
                if (guest.needsPizza) {
                    const x = gridToPixel(guest.gridX) + 10;
                    const y = gridToPixel(guest.gridY) + 10;
                    const size = gameConfig.cellSize - 20;
                    ctx.fillRect(x, y, size, size);

                    // Draw request indicator (white border)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, size, size);
                }
            });

            // Draw player (blue when empty, yellow when carrying pizzas)
            ctx.fillStyle = game.player.pizzasCarried > 0 ? '#ffff00' : '#0080ff';
            const playerX = gridToPixel(game.player.gridX) + 5;
            const playerY = gridToPixel(game.player.gridY) + 5;
            const playerSize = gameConfig.cellSize - 10;
            ctx.fillRect(playerX, playerY, playerSize, playerSize);
        }

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Configuration loading functions
        function loadConfig() {
            document.getElementById('configFile').click();
        }

        function handleConfigFile(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const newConfig = JSON.parse(e.target.result);
                        applyConfig(newConfig);
                        resetGame();
                    } catch (error) {
                        alert('Error loading config file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        function applyConfig(newConfig) {
            // Merge new config with existing config
            Object.assign(gameConfig, newConfig);

            // Update canvas size based on grid
            canvas.width = gameConfig.gridSize * gameConfig.cellSize;
            canvas.height = gameConfig.gridSize * gameConfig.cellSize;

            // Update game counter reference
            game.counter = gameConfig.counter;
        }

        function resetGame() {
            // Reset game state with grid positions
            game.player.gridX = gameConfig.player.startGridX;
            game.player.gridY = gameConfig.player.startGridY;
            game.player.pizzasCarried = 0;
            game.player.maxPizzas = gameConfig.playerMaxPizzas;
            game.pizzas = [];
            game.guests = [];
            game.score = 0;
            game.touchControls = {};

            // Reinitialize game objects
            initGame();
        }

        // Auto-load default config on startup
        async function loadDefaultConfig() {
            try {
                const response = await fetch('game-config.json');
                if (response.ok) {
                    const config = await response.json();
                    applyConfig(config);
                }
            } catch (error) {
                console.log('Using default configuration (could not load game-config.json)');
            }
        }

        // Frame capture function
        function captureGameFrame() {
            return {
                player: {
                    gridX: game.player.gridX,
                    gridY: game.player.gridY,
                    pizzasCarried: game.player.pizzasCarried
                },
                pizzas: game.pizzas.map(p => ({ gridX: p.gridX, gridY: p.gridY })),
                guests: game.guests.map(g => ({
                    gridX: g.gridX,
                    gridY: g.gridY,
                    needsPizza: g.needsPizza
                })),
                score: game.score,
                canvas: {
                    width: canvas.width,
                    height: canvas.height
                },
                grid: {
                    size: gameConfig.gridSize,
                    cellSize: gameConfig.cellSize
                }
            };
        }

        // Recording functions
        function recordKeystroke(key, action, timestamp) {
            if (!recording.isRecording) return;

            const frame = captureGameFrame();
            const absoluteTimestamp = new Date(recording.startTime + timestamp).toISOString();

            // Find nearby speech for reasoning
            const reasoning = findNearbyReasoning(timestamp);

            const gameFrame = {
                timestamp: absoluteTimestamp,
                data: {
                    game_id: recording.gameId,
                    frame: frame,
                    state: determineGameState(),
                    score: game.score,
                    action_input: {
                        id: recording.actionCounter++,
                        data: {
                            game_id: recording.gameId,
                            key: key,
                            action: action,
                            timestamp: timestamp
                        },
                        reasoning: reasoning
                    },
                    guid: generateGuid(),
                    full_reset: false
                }
            };

            recording.gameFrames.push(gameFrame);

            // Also keep the old format for backwards compatibility
            recording.keystrokes.push({
                key: key,
                action: action,
                timestamp: timestamp,
                gameState: frame
            });
        }

        function findNearbyReasoning(actionTimestamp) {
            // Find speech within 3 seconds before or 1 second after the action
            const speechBefore = recording.transcription.filter(t =>
                t.timestamp <= actionTimestamp &&
                (actionTimestamp - t.timestamp) <= 3000
            );

            const speechAfter = recording.transcription.filter(t =>
                t.timestamp > actionTimestamp &&
                (t.timestamp - actionTimestamp) <= 1000
            );

            const allSpeech = [...speechBefore, ...speechAfter]
                .sort((a, b) => Math.abs(a.timestamp - actionTimestamp) - Math.abs(b.timestamp - actionTimestamp));

            return allSpeech.length > 0 ? allSpeech[0].text : "No speech detected";
        }

        function determineGameState() {
            // Determine if game is finished or ongoing
            if (game.score >= 50) return "FINISHED"; // Example win condition
            if (game.guests.length === 0 && game.pizzas.length === 0) return "FINISHED";
            return "NOT_FINISHED";
        }

        async function startRecording() {
            try {
                // Request microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Setup MediaRecorder for audio
                recording.mediaRecorder = new MediaRecorder(stream);
                recording.audioChunks = [];

                recording.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recording.audioChunks.push(event.data);
                    }
                };

                // Setup Web Speech API for transcription
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recording.recognition = new SpeechRecognition();
                    recording.recognition.continuous = true;
                    recording.recognition.interimResults = true;
                    recording.recognition.lang = 'en-US';

                    console.log('Speech recognition initialized');

                    recording.recognition.onstart = () => {
                        console.log('Speech recognition started');
                        updateStatusMessage('Speech recognition active');
                    };

                    recording.recognition.onresult = (event) => {
                        console.log('Speech recognition result:', event);
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            const timestamp = Date.now() - recording.startTime;
                            const isFinal = event.results[i].isFinal;
                            const confidence = event.results[i][0].confidence;

                            console.log(`Transcript (${isFinal ? 'final' : 'interim'}):`, transcript);

                            // Update or add transcription entry
                            if (isFinal) {
                                recording.transcription.push({
                                    text: transcript,
                                    timestamp: timestamp,
                                    confidence: confidence
                                });
                                updateStatusMessage(`Transcribed: "${transcript}"`);
                            }
                        }
                    };

                    recording.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        updateStatusMessage(`Speech recognition error: ${event.error}`);
                    };

                    recording.recognition.onend = () => {
                        console.log('Speech recognition ended');
                        if (recording.isRecording) {
                            // Restart if still recording
                            setTimeout(() => {
                                try {
                                    recording.recognition.start();
                                    console.log('Speech recognition restarted');
                                } catch (e) {
                                    console.error('Failed to restart speech recognition:', e);
                                }
                            }, 100);
                        }
                    };

                    try {
                        recording.recognition.start();
                        console.log('Starting speech recognition...');
                    } catch (e) {
                        console.error('Failed to start speech recognition:', e);
                        updateStatusMessage('Speech recognition failed to start');
                    }
                } else {
                    console.log('Speech recognition not supported');
                    updateStatusMessage('Speech recognition not supported in this browser');
                }

                // Start recording
                recording.mediaRecorder.start(1000); // Record in 1-second chunks
                recording.isRecording = true;
                recording.startTime = Date.now();
                recording.keystrokes = [];
                recording.transcription = [];
                recording.gameFrames = [];
                recording.gameId = generateGameId();
                recording.actionCounter = 0;

                updateRecordingUI();
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Could not access microphone. Recording will only capture keystrokes.');

                // Start keystroke-only recording
                recording.isRecording = true;
                recording.startTime = Date.now();
                recording.keystrokes = [];
                recording.transcription = [];
                recording.gameFrames = [];
                recording.gameId = generateGameId();
                recording.actionCounter = 0;
                updateRecordingUI();
            }
        }

        function stopRecording() {
            recording.isRecording = false;

            if (recording.mediaRecorder && recording.mediaRecorder.state !== 'inactive') {
                recording.mediaRecorder.stop();
                recording.mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }

            if (recording.recognition) {
                recording.recognition.stop();
            }

            updateRecordingUI();
        }

        function toggleRecording() {
            if (recording.isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function updateRecordingUI() {
            const recordBtn = document.getElementById('recordBtn');
            const exportBtn = document.getElementById('exportBtn');
            const status = document.getElementById('recordingStatus');

            if (recording.isRecording) {
                recordBtn.textContent = '‚èπÔ∏è Stop Recording';
                recordBtn.classList.add('recording');
                exportBtn.classList.add('disabled');
                exportBtn.disabled = true;
                status.textContent = 'Recording gameplay and audio...';
                status.classList.add('active');
            } else {
                recordBtn.textContent = 'üî¥ Start Recording';
                recordBtn.classList.remove('recording');

                if (recording.keystrokes.length > 0) {
                    exportBtn.classList.remove('disabled');
                    exportBtn.disabled = false;
                    const transcriptCount = recording.transcription.length;
                    status.textContent = `Recording complete. ${recording.keystrokes.length} actions, ${transcriptCount} speech segments recorded.`;
                } else {
                    status.textContent = 'Ready to record gameplay and audio';
                }
                status.classList.remove('active');
            }
        }

        function updateStatusMessage(message) {
            const status = document.getElementById('recordingStatus');
            if (recording.isRecording) {
                status.textContent = message;
            }
        }

        function exportRecording() {
            if (recording.gameFrames.length === 0) {
                alert('No recording data to export');
                return;
            }

            // Create JSONL content (each line is a JSON object)
            const jsonlContent = recording.gameFrames
                .map(frame => JSON.stringify(frame))
                .join('\n');

            // Download JSONL file
            const jsonlBlob = new Blob([jsonlContent], { type: 'application/jsonl' });
            const jsonlUrl = URL.createObjectURL(jsonlBlob);
            const jsonlLink = document.createElement('a');
            jsonlLink.href = jsonlUrl;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            jsonlLink.download = `pizza-game-aligned-${recording.gameId}-${timestamp}.jsonl`;
            document.body.appendChild(jsonlLink);
            jsonlLink.click();
            document.body.removeChild(jsonlLink);
            URL.revokeObjectURL(jsonlUrl);

            // Also create legacy JSON format for backwards compatibility
            const legacyData = {
                session: {
                    gameId: recording.gameId,
                    startTime: new Date(recording.startTime).toISOString(),
                    duration: Date.now() - recording.startTime,
                    totalActions: recording.keystrokes.length,
                    totalFrames: recording.gameFrames.length
                },
                keystrokes: recording.keystrokes,
                transcription: recording.transcription,
                audioAvailable: recording.audioChunks.length > 0,
                alignedFrames: recording.gameFrames
            };

            const legacyBlob = new Blob([JSON.stringify(legacyData, null, 2)], { type: 'application/json' });
            const legacyUrl = URL.createObjectURL(legacyBlob);
            const legacyLink = document.createElement('a');
            legacyLink.href = legacyUrl;
            legacyLink.download = `pizza-game-legacy-${recording.gameId}-${timestamp}.json`;
            document.body.appendChild(legacyLink);
            legacyLink.click();
            document.body.removeChild(legacyLink);
            URL.revokeObjectURL(legacyUrl);

            // Download audio if available
            if (recording.audioChunks.length > 0) {
                const audioBlob = new Blob(recording.audioChunks, { type: 'audio/webm' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audioLink = document.createElement('a');
                audioLink.href = audioUrl;
                audioLink.download = `pizza-game-audio-${recording.gameId}-${timestamp}.webm`;
                document.body.appendChild(audioLink);
                audioLink.click();
                document.body.removeChild(audioLink);
                URL.revokeObjectURL(audioUrl);
            }

            // Show summary
            alert(`Exported ${recording.gameFrames.length} aligned game frames!\n\nFiles:\n- JSONL: aligned game data\n- JSON: legacy format\n- WebM: audio recording (if available)`);
        }

        function alignTranscriptionWithKeystrokes(keystrokes, transcription) {
            const aligned = [];

            transcription.forEach(speech => {
                // Find keystrokes that occurred around the same time as this speech
                const timeWindow = 2000; // 2 second window
                const nearbyKeystrokes = keystrokes.filter(k =>
                    Math.abs(k.timestamp - speech.timestamp) < timeWindow
                );

                aligned.push({
                    speech: speech,
                    nearbyActions: nearbyKeystrokes,
                    timeWindow: timeWindow
                });
            });

            return aligned;
        }

        // Start game
        loadDefaultConfig().then(() => {
            initGame();
            gameLoop();
        });
    </script>
</body>
</html>